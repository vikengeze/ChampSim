PQ = Packet Queue
FCTB = ???
bpbp[5] = Πινακας στον οποιον κραταει τα accesses --> 
--> 0 == Αριθμος instruction prefetches
--> 1 == Οι εντολες που ειναι στην ιδια σελιδα
--> 2 == Οι εντολες που ειναι instruction prefetches εκτος σελιδας
--> 3 == Prefetch εκτος σελιδας που ειναι hits στην TLB
--> 4 == Prefetch εκτος σελιδας που ειναι miss στην TLB
			 bpbp[5]; // 0: # instruction prefetches 1: portion of instruction prefetches that are in the same page 2: portion of beyond page boundaries instruction prefetches 3: beyond page boundaries prefetches that hit in the TLB hierarchy 4: beyond page boundaries prefetches that miss in the TLB

Building -- (sp + viken μονο για Morrigan)
./build_champsim.sh bimodal no no no no lru 1 sp viken
--builder (branch_pred) (L1I) (LID) (L2C) (LLC) (LLC_REPLACEMENT) (NUMCORE) (STLB_PREF) (NAME)

Running -- (Binary name w/o spviken for !Morrigan)
./run_champsim.sh spviken-bimodal-no-no-no-lru-1core 1 10 srv_32
--runner (bin_name) (warmup in M) (sim in M) (trace_file)

prefetch_page παιρνει:

ip, base_addr, pf_addr, fill_level, pq_id, free, update_free, free_distance, id, type, iflag, lad, confidence, irip

ip = instruction p
base_address = current vpn(virtual page number)
pf_addr = page to prefetch
fill_level = FILL_L2
pq_id = 
free = 
update_free = 
free_distance = 
id = instruction ID
type = 
iflag = 
lad = 
confidence = Μας ενδιαφερει μονο για Markov
irip = 
Genika to Morrigan kanei prefetching stin STLB, diladi sto deutero level tou TLB
To build pou exei to morrigan exei mia ITLB kai mia DTLB sto prwto level, kai tin STLB sto deutero level.
Thewritika, afou ftiaxw loipon egw ena ML gia tin STLB, tha prepei na afora kai ta 2, akomi kai an mas endiaferei kata kurio logo to DTLB.

Twra to Morrigan praktika einai etoimo kai doulevei me opoion STLB prefetcher tou dwsw egw. Egw omws thelw na trexw nevrwniko kai oxi aplo TLB prefetcher. Opote tha prepei kapws na to ekpaideusw kai kapws na to treksw. 


####################################################################################

ASP(Arbitrary Stride Prefetching) THEORY: 

Prediction Table entries have four fields:
--> PC(Program Counter) for indexing -- Previous page that caused TLB miss on PC -- Stride -- state(unchanged stride for 2+ consecutive table hits)

ASP(Arbitrary Stride Prefetching) CODE: 
Table Size = Associativity = 128
bits = index = 0

For (i=0; i<assoc(=128))
	if (ip hit from tracker)
	{
		if( current VPN < previous VPN from tracker){
			new stride = diff
		}
		else{
		new stride = -diff
		}
		if (same stride && same sign){
			state ++ 
		}
		else{
			init state, stride, sign
		}

		if (state >=2)
		{
			update free bit and pf_addr
			PREFETCH PAGE
		}

		update previous_vpn;
		break;
	}

	if (i==assoc(table is fully traversed until hit or no hit) --> LRU policy

####################################################################################

DP(Distance Prefetching) THEORY:



DP(Distance Prefetching) CODE:

Using info_tracker --> (distance, pr1, pr2(, timestamp), flag)

Table Size = Associativity = 128
bits = index = 0

Calculate current_distance_indexing and set ignore=1 if indexing > limit

if (ignore == 1) --> cx = 0 

else {
	index = 0 (same way as before)
	pos = search distance table

	if (pos == -1){ (δηλαδη δεν βρεθηκε το distance)
		evict from distance table (LRU policy)
	}
	else{ 
		for pr1 and pr2:
		if not invalid {
			calculate cache_line_position and prefetch to-do
			PREFETCH PAGE
		}
	}

	if (previous distance != 0){
		update pr1 if invalid
		else update pr2 if invalid
		else  update pr1 if flag=0
		else update pr2
	}

}

####################################################################################
PREFETCHING
handle_read():
if (way >= 0) // read hit
{
	if(LOAD)
	{
		update prefetchers(operate l1i, l1d, l2c, llc prefetchers)
	}
}
else // read miss
{
	miss_handled=1
	if new miss
	{
		if LLC
		{
			check DRAM free space -> miss_handled=0
		}
		elif STLB
		{
			STLB_prefetcher_operate() --> only one ΚΑΙ ΛΕΙΠΕΙ ΤΟ miss_handled=0
		}
	}
	elif not enough MSHR resource
	{
		miss_handled=0
	}
	elif miss is already in-flight 
	{
		//check if read for ownership

	}

	if miss_handled
	{
		prefetchers_operate for l1i, l1d, l2c, llc
	}
}

handle_prefetch():
καλειται στην
CACHE::operate()
{
	handle_fill();
	handle_writeback();
	reads_available_this_cycle = MAX_READ;
	handle_read();
	if (PQ.occupancy && (reads_available_this_cycle > 0))
		if(cache_type != IS_STLB)
			handle_prefetch();
}